/*******************************************************************************
**+--------------------------------------------------------------------------+**
**|                            ****                                          |**
**|                            ****                                          |**
**|                            ******o***                                    |**
**|                      ********_///_****                                   |**
**|                      ***** /_//_/ ****                                   |**
**|                       ** ** (__/ ****                                    |**
**|                           *********                                      |**
**|                            ****                                          |**
**|                            ***                                           |**
**|                                                                          |**
**|         Copyright (c) 2015 Texas Instruments Incorporated                |**
**|                        ALL RIGHTS RESERVED                               |**
**|                                                                          |**
**| Permission to use, copy, modify, or distribute this software,            |**
**| whether in part or in whole, for any purpose is forbidden without        |**
**| a signed licensing agreement and NDA from Texas Instruments              |**
**| Incorporated (TI).                                                       |**
**|                                                                          |**
**| TI makes no representation or warranties with respect to the             |**
**| performance of this computer program, and specifically disclaims         |**
**| any responsibility for any damages, special or consequential,            |**
**| connected with the use of this program.                                  |**
**|                                                                          |**
**+--------------------------------------------------------------------------+**
*******************************************************************************/

#ifndef VLIB_HAARDETECTOBJECT_CLASSIFIER_H_
#define VLIB_HAARDETECTOBJECT_CLASSIFIER_H_ 1

/* This file defines the ada boost classifier for pedestrian detection
   Data has been generated for base resolution of 640x480, assuming pitch
   of the image as 640, with sub sampling factor of 3 in 'y' direction.
 */

#include "VLIB_haarDetectObjects_types.h"

static VLIB_HAARDETOBJ_sTree    classifierTree[7] =
{
    /*Tree #  0*/
    {
        {
            { 0xFF,  2,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 5120, 5144, 8960, 8984, }, { 5128, 5136, 8968, 8976, }, { 5128, 5136, 8968, 8976, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 1920, 1944, 7680, 7704, }, { 1928, 1936, 7688, 7696, }, { 1928, 1936, 7688, 7696, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 5130, 5135, 10250, 10255, }, { 7690, 7695, 10250, 10255, }, { 7690, 7695, 10250, 10255, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { -3665, 4422,   74 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { -3610, -22100, -3620, 4530, 27040, -22925, 27687, 4514, },
        /* Rect Type*/
        { 4, 4, 2 },
    },
    /*Tree #  1*/
    {
        {
            { 0xFF,  2,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 3846, 3857, 10246, 10257, }, { 7046, 7057, 10246, 10257, }, { 7046, 7057, 10246, 10257, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 649,  654, 2569, 2574, }, { 1289, 1294, 1929, 1934, }, { 1289, 1294, 1929, 1934, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 1928, 1936, 4488, 4496, }, { 3208, 3216, 4488, 4496, }, { 3208, 3216, 4488, 4496, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { 1100, -306, -202 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { 10700, 21005, -20007, 22085, 10610, -3704, -20217, -3724, },
        /* Rect Type*/
        { 2, 4, 2 },
    },
    /*Tree #  2*/
    {
        {
            { 0xFF,  2,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 8332, 8344, 8972, 8984, }, { 8338, 8344, 8978, 8984, }, { 8338, 8344, 8978, 8984, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 7690, 7699, 8970, 8979, }, { 7693, 7696, 8973, 8976, }, { 7693, 7696, 8973, 8976, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 7687, 7696, 8967, 8976, }, { 7690, 7693, 8970, 8973, }, { 7690, 7693, 8970, 8973, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { 155,  187,  159 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { -22500, 13300, 9900, 10397, 3170, 13300, 9900, 13300, },
        /* Rect Type*/
        { 1, 4, 4 },
    },
    /*Tree #  3*/
    {
        {
            { 0xFF,  3,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 3213, 3219, 4493, 4499, }, { 3215, 3217, 4495, 4497, }, { 3215, 3217, 4495, 4497, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 2575, 2581, 4495, 4501, }, { 2577, 2579, 4497, 4499, }, { 2577, 2579, 4497, 4499, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 2577, 2583, 3857, 3863, }, { 2579, 2581, 3859, 3861, }, { 2579, 2581, 3859, 3861, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { -118, -209,  -82 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { 11059, 11039, 12159, 1015, 14059, 11039, 11059, -20394, },
        /* Rect Type*/
        { 4, 4, 4 },
    },
    /*Tree #  4*/
    {
        {
            { 0xFF,  3,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 5122, 5143, 8322, 8343, }, { 5129, 5136, 8329, 8336, }, { 5129, 5136, 8329, 8336, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 6403, 6418, 10243, 10258, }, { 8323, 8338, 10243, 10258, }, { 8323, 8338, 10243, 10258, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 3847, 3857, 10247, 10257, }, { 7047, 7057, 10247, 10257, }, { 7047, 7057, 10247, 10257, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { -3424, 2156,  112 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { 609, -20346,  719,  584, 27934, -19356, 27934,  284, },
        /* Rect Type*/
        { 4, 2, 2 },
    },
    /*Tree #  5*/
    {
        {
            { 0xFF,  3,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  2,  2,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  2,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 650,  654, 2570, 2574, }, { 1290, 1294, 1930, 1934, }, { 1290, 1294, 1930, 1934, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 1287, 1293, 2567, 2573, }, { 1287, 1290, 1927, 1930, }, { 1930, 1933, 2570, 2573, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 2569, 2575, 3849, 3855, }, { 3209, 3215, 3849, 3855, }, { 3209, 3215, 3849, 3855, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { -191,  -76,  -45 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { 21500, 8901, 20077, -16069, 1002, 9071, 1002, -16969, },
        /* Rect Type*/
        { 4, 3, 2 },
    },
    /*Tree #  6*/
    {
        {
            { 0xFF,  2,  0,  0, }, /*Weight of Node #0, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #1, 0xFF is treated as -1*/
            { 0xFF,  3,  0,  0, }, /*Weight of Node #2, 0xFF is treated as -1*/
        },
        3,
        {
            { { 8320, 8332, 8960, 8972, }, { 8326, 8332, 8966, 8972, }, { 8326, 8332, 8966, 8972, }, }, /*Node #0 :: Rect #0, Rect #1, Rect #2*/
            { { 7685, 7694, 8965, 8974, }, { 7688, 7691, 8968, 8971, }, { 7688, 7691, 8968, 8971, }, }, /*Node #1 :: Rect #0, Rect #1, Rect #2*/
            { { 7047, 7053, 8327, 8333, }, { 7049, 7051, 8329, 8331, }, { 7049, 7051, 8329, 8331, }, }, /*Node #2 :: Rect #0, Rect #1, Rect #2*/
        },
        /* Node #0 threshold, Node #1 threshold, Node #2 threshold*/
        { -120,  190, -140 },
        /* Result score, score[0] --> (Node #0, #1, #2 all check failed), score[7] --> (Node #0, #1, #2 all check passed)
           One bit is allocated to one node check. index to below result score is generated by (index |= ((Node #i check result) << i))
           Tree Score = score[index].*/
        { 11092,  744, 10792, 6337, 11692, -22121, 12792, 6538, },
        /* Rect Type*/
        { 1, 4, 4 },
    }
};

static VLIB_HAARDETOBJ_sClassifier    pedestrianClassifier =
{
    4,                             /*numStages*/
    3,                             /*maxNodesPerTree*/
    { 16, 24 },                    /*patchSize[2] {H,W}*/
    { 2, 2, 1, 2 },                /*numTrees[VLIB_HAARDETOBJ_MAX_STAGES]*/
    { 2, 3, 3, 3 },                /*maxRectangle[VLIB_HAARDETOBJ_MAX_STAGES]*/
    { -28100, -43000, -44127, -45574 }, /*stageTh[VLIB_HAARDETOBJ_MAX_STAGES]*/
    classifierTree
};
#endif

/* ======================================================================== */
/*  End of file:  VLIB_haarDetectObjectsClassifier_idat.h                   */
/* ======================================================================== */

