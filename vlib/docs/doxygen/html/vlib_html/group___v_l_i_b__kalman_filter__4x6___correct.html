<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_kalmanFilter_4x6_Correct</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_kalmanFilter_4x6_Correct</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__kalman_filter__4x6___correct.html#g3cd1fcb765d6b44b9838dfd33b80a810">VLIB_kalmanFilter_4x6_Correct</a> (<a class="el" href="structvlib__kalman_filter__4x6.html">VLIB_kalmanFilter_4x6</a> *KF, const int16_t *restrict Z, int16_t *restrict Residual)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3cd1fcb765d6b44b9838dfd33b80a810"></a><!-- doxytag: member="c64P/VLIB_kalmanFilter_4x6_Correct.h::VLIB_kalmanFilter_4x6_Correct" ref="g3cd1fcb765d6b44b9838dfd33b80a810" args="(VLIB_kalmanFilter_4x6 *KF, const int16_t *restrict Z, int16_t *restrict Residual)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_kalmanFilter_4x6_Correct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvlib__kalman_filter__4x6.html">VLIB_kalmanFilter_4x6</a> *&nbsp;</td>
          <td class="paramname"> <em>KF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>Residual</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>The state of the Kalman filter is defined using the following structure (the expected bit precision for each matrix is noted in the comments). The variable sD and mD represent the dimensionality of the state and measurement vectors and have values of 6 and 4 respectively. <div class="fragment"><pre class="fragment">
  typedef struct VLIB_kalmanFilter_4x6 {
   int16_t transition[sD_4x6*sD_4x6];            // state transition matrix
   int16_t errorCov[sD_4x6*sD_4x6];              // a priori error covariance matrix
   int16_t predictedErrorCov[sD_4x6*sD_4x6];     // predicted error covariance matrix
   int16_t state[sD_4x6];                        // state of the process
   int16_t predictedState[sD_4x6];               // predicted state of the process
   int16_t measurement[mD_4x6*sD_4x6];           // measurement matrix (relating state to measurement)
   int16_t processNoiseCov[sD_4x6*sD_4x6];       // process noise covariance matrix
   int16_t measurementNoiseCov[mD_4x6*mD_4x6];   // measurement noise covariance matrix
   int16_t kalmanGain[sD_4x6*mD_4x6];            // Kalman gain, K
   int16_t temp1[sD_4x6*sD_4x6];
   int16_t temp2[sD_4x6*sD_4x6];
   int16_t temp3[sD_4x6*sD_4x6];
   int16_t tempBuffers[mD_4x6*mD_4x6*2];
   int32_t scaleFactor;                    // Scales the matrix M = (H*P1*H' + R)
                                       //to ensure that its inverse does not overflow 32 bits.
   }VLIB_kalmanFilter_4x6;
</pre></div> In VLIB_kalmanFilter_4x6_Correct, input and output are int16_t type</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*KF</em>&nbsp;</td><td>Pointer to struct VLIB_kalmanFilter_4x6 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*Z</em>&nbsp;</td><td>Pointer to array (dimension 4x1) containing measurement (SQ10.5) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*Residual</em>&nbsp;</td><td>Pointer to array to store the residual error (SQ10.5)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
