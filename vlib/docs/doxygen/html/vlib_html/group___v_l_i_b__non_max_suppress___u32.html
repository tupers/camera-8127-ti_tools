<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_nonMaxSuppress_U32</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_nonMaxSuppress_U32</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__non_max_suppress___u32.html#g7f1822d0baddc7e8fbece07824cdbf4d">VLIB_nonMaxSuppress_U32</a> (const uint32_t *restrict im, int32_t w, int32_t h, int32_t filterWidth, uint32_t threshold, uint32_t *restrict buffer, int16_t *restrict pixIndex)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g7f1822d0baddc7e8fbece07824cdbf4d"></a><!-- doxytag: member="c64P/VLIB_nonMaxSuppress_U32.h::VLIB_nonMaxSuppress_U32" ref="g7f1822d0baddc7e8fbece07824cdbf4d" args="(const uint32_t *restrict im, int32_t w, int32_t h, int32_t filterWidth, uint32_t threshold, uint32_t *restrict buffer, int16_t *restrict pixIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_nonMaxSuppress_U32           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *restrict&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>filterWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *restrict&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pixIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description</b></dt><dd>This function implements a non-maximum suppression algorithm with programmable filter size. It compares the value of each input pixel against its neighbors. For an output pixel to be "on" (coordinate pair included in the <code>pixIndex</code> list), the input pixel value must be both:<ul>
<li>Greater than or equal to its neighbors</li><li>Greater than the <code>threshold</code> value</li></ul>
</dd></dl>
If the above conditions are not met simultanously, the output coordinate will not be included in the <code>pixIndex</code> list.<p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*im</em>&nbsp;</td><td>Input image (UQ32.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>Image width (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h</em>&nbsp;</td><td>Image height (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterWidth</em>&nbsp;</td><td>Filter width (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Threshold for the Maxima (UQ32.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*buffer</em>&nbsp;</td><td>Buffer for internal use (UQ32.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pixIndex</em>&nbsp;</td><td>List of coordinates of non-maxima locations (SQ15.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions</b></dt><dd><ul>
<li>The only acceptable values for <code>filterWidth</code> are 3, 5, and 7, representing filter masks sizes 3x3, 5x5, and 7x7, respectively.</li><li>The internal buffer (<code>buffer</code>) size should be at least ((2 * <code>filterWidth</code>) + (<code>w</code> * <code>h</code>))*sizeof(uint32_t) bytes</li><li>The output buffer (<code>pixIndex</code>) size should be (2*w*h+2)*sizeof(uint16_t) bytes</li><li>The format of the output buffer (<code>pixIndex</code>) is as follows:<ul>
<li><code>pixIndex</code>[] = {numPoints, 0, y1, x1, y2, x2, y3, x3, yn, xn}<ul>
<li>where <em>n</em> = numPoints = the number of points contained in the list.</li></ul>
</li></ul>
</li><li>Due the the method of filtering, the output list will not include pixel coordinates which are located within the border of the input image. The number of border pixels is defined by the following equation: border pixels = (filterWidth-1)/2.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
