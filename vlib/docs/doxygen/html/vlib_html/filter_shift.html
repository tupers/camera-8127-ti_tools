<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: Output Shift by Filtering Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">VLIB Function Reference</a></div>
<h1><a class="anchor" name="filter_shift">Output Shift by Filtering Functions</a></h1><h2><a class="anchor" name="intro49">
Introduction and Use Cases</a></h2>
Of the several VLIB kernels that work on an input image to produce an output image, few of them that use filters tend to produce an output that is cropped and shifted with respect to the input. This is explained below with an example. Two ways to handle such misalignments are also discussed.<h2><a class="anchor" name="description49">
Causes for Output Crop and Alignment Shift</a></h2>
An example causing output shift is the use of a filter that finds, for each pixel, the minimum of pixels over a 3 x 3 neighborhood in an input image of height 'h' and width 'w'. The border pixels of the input image are missing valid neighbors for the operation, so there is no output computed for these border pixels. Therefore, the output is reduced in size and has only (h-2) x (w-2) valid pixels even though the output is expected to hold h x w pixels.<p>
When filtering is performed on images, it is customary to initially allocate same memory to both input and output buffers to hold h x w pixels each. And when the VLIB function is called, the pointers to the first pixel of input and output buffers are passed as arguments to the VLIB function.<p>
In such cases, the first output pixel is obtained by processing the first valid non-border input pixel. This results in a misalignment between the input and output once the output buffer is filled with valid data. There is also a reduction in size of output image as explained above. The shift in this case is one pixel towards left and one pixel towards top.<p>
This is illustrated below:<p>
<div align="center">
<img src="filter_shift_1.jpg" alt="filter_shift_1.jpg">
</div>
 <div align="center">
<img src="filter_shift_2.jpg" alt="filter_shift_2.jpg">
</div>
 <div align="center">
<img src="filter_shift_3.jpg" alt="filter_shift_3.jpg">
</div>
<p>
The example above illustrates a 3x3 filtering operation, which resulted in the following modifications:<ul>
<li>Left shift = 1 pixel</li><li>Top shift = 1 pixel</li><li>Width crop = 2 pixels</li><li>Height crop = 2 pixels</li></ul>
<p>
This effect can be generalized to different kernel filtering sizes, such as 5x5, and 7x7 by using the following equations:<ul>
<li>Left shift = (filter width - 1)/2 pixels</li><li>Top shift = (filter height - 1)/2 pixels</li><li>Width crop = (filter width - 1) pixels</li><li>Height crop = (filter height - 1) pixels</li></ul>
<h2><a class="anchor" name="solution49">
Handling Output Shifts</a></h2>
The user can choose from the following options to handle the shift depending on application requirements.<p>
1. User padding of the input and output with predefined data, and using a pointer offset for output, cropping of output is prevented during process. Also, there is no misalignment between input and output pixels.<ul>
<li>Procedure:<ol type=a>
<li>The input and output are padded with meaningful data (zeros, gray values, input border pixel mirroring values, etc) along the border.</li><li>The pointer to first valid pixel of the output should be passed to the function.</li><li>The new width and height of the image obtained after padding should be passed as image size to the function.</li><li>Border pixels should be removed from input and output after processing.</li></ol>
</li></ul>
<p>
<div align="center">
<img src="filter_shift_4.jpg" alt="filter_shift_4.jpg">
</div>
 <div align="center">
<img src="filter_shift_5.jpg" alt="filter_shift_5.jpg">
</div>
<p>
<ul>
<li>Pros:<ol type=a>
<li>Aids in recursive usage of function.</li><li>Standard output size equal to that of the input.</li><li>No alignment issues between input and output.</li><li>Border pixels of input image are processed.</li></ol>
</li><li>Cons:<ol type=a>
<li>Border pixels are invalid anyway, so it takes extra time for preprocessing to add border pixels, for processing border pixels within the VLIB function, and for postprocessing to remove border pixels.</li><li>More memory required to preprocess input to pad with additional pixel values, and remove borders on input and output after processing.</li><li>Padding may need to be larger than just a single pixel depending on the specific VLIB function alignment and "multiple-of" requirements.</li></ol>
</li></ul>
<p>
2. Leave input unchanged, and pass the pointer offset for output.<ul>
<li>Procedure:<ol type=a>
<li>The pointer to first valid pixel (non-border pixel) of the output should be passed to the function.</li></ol>
</li></ul>
<p>
<div align="center">
<img src="filter_shift_1.jpg" alt="filter_shift_1.jpg">
</div>
 <div align="center">
<img src="filter_shift_6.jpg" alt="filter_shift_6.jpg">
</div>
<p>
<ul>
<li>Pros:<ol type=a>
<li>Aids in recursive usage of function.</li><li>Standard output size equal to that of the input.</li><li>No alignment issues between input and output.</li><li>Saves memory and time as no pre/post processing is needed.</li></ol>
</li><li>Cons:<ol type=a>
<li>Border pixels of the input are not/incorrectly processed, resulting in the output having invalid border pixels. </li></ol>
</li></ul>
<hr size="1"><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
